//------Generated by the Framework and can be changed-----//
//------Sample of collect All Select Google Fit Step Data-----//
package br.ufc.frameworkkotlin.model.mapek.monitoring.GoogleFit.Samples

import android.util.Log
import android.widget.Toast
import br.ufc.frameworkkotlin.model.mapek.monitoring.GoogleFit.GoogleFitAPI
import br.ufc.frameworkkotlin.model.utils.Constants
import com.google.android.gms.fitness.Fitness
import com.google.android.gms.fitness.data.*
import com.google.android.gms.fitness.request.DataDeleteRequest
import com.google.android.gms.fitness.request.DataReadRequest
import com.google.android.gms.fitness.request.DataUpdateRequest
import com.google.android.gms.fitness.result.DataReadResponse
import com.google.android.gms.tasks.Task
import java.text.DateFormat
import java.util.*
import java.util.concurrent.TimeUnit

enum class FitActionRequestCode{
    INSERT_AND_READ_DATA,
    UPDATE_AND_READ_DATA,
    DELETE_DATA
}

class GoogleFitStepData(val api:GoogleFitAPI) {
    private val TAG = GoogleFitStepData::class.java.simpleName


    fun fitSignIn(requestCode: Int) {
        if (api.oAuthPermissionsApproved()) {
            performActionForRequestCode(requestCode)
        } else{
            api.requestFitPermission()
        }
    }

    fun performActionForRequestCode(requestCode: Int) = when (requestCode) {
        Constants.GOOGLE_FIT_PERMISSIONS_REQUEST_CODE -> insertAndReadData()
        FitActionRequestCode.INSERT_AND_READ_DATA.ordinal -> insertAndReadData()
        FitActionRequestCode.UPDATE_AND_READ_DATA.ordinal -> updateAndReadData()
        FitActionRequestCode.DELETE_DATA.ordinal -> deleteData()
        else -> {}
    }

    private fun insertAndReadData() = insertData().continueWith { readHistoryData() }

    /** Creates a {@link DataSet} and inserts it into user's Google Fit history. */
    private fun insertData(): Task<Void> {
        // Create a new dataset and insertion request.
        val dataSet = insertFitnessData()

        Toast.makeText(api.activity, "Inserting the dataset in the History API.", Toast.LENGTH_LONG).show()
        // Then, invoke the History API to insert the data.
        Log.i(TAG, "Inserting the dataset in the History API.")
        return Fitness.getHistoryClient(api.activity, api.getGoogleAccount())
            .insertData(dataSet)
            .addOnSuccessListener { Log.i(TAG, "Data insert was successful!")
                Toast.makeText(api.activity, "Data insert was successful!", Toast.LENGTH_LONG).show()}
            .addOnFailureListener { exception ->
                Log.e(TAG, "There was a problem inserting the dataset.", exception)
                Toast.makeText(api.activity, "There was a problem inserting the dataset.", Toast.LENGTH_LONG).show()
            }
    }

    private fun readHistoryData(): Task<DataReadResponse> {
        // Begin by creating the query.
        val readRequest = queryFitnessData()

        // Invoke the History API to fetch the data with the query
        return Fitness.getHistoryClient(api.activity, api.getGoogleAccount())
            .readData(readRequest)
            .addOnSuccessListener { dataReadResponse ->
                // For the sake of the sample, we'll print the data so we can see what we just
                // added. In general, logging fitness information should be avoided for privacy
                // reasons.
                printData(dataReadResponse)
            }
            .addOnFailureListener { e ->
                Log.e(TAG, "There was a problem reading the data.", e)
                Toast.makeText(api.activity, "There was a problem reading the data.", Toast.LENGTH_LONG).show()
            }
    }

    private fun insertFitnessData(): DataSet {
        Log.i(TAG, "Creating a new data insert request.")
        Toast.makeText(api.activity, "Creating a new data insert request.", Toast.LENGTH_LONG).show()

        // [START build_insert_data_request]
        // Set a start and end time for our data, using a start time of 1 hour before this moment.
        val calendar = Calendar.getInstance(TimeZone.getTimeZone("UTC"))
        val now = Date()
        calendar.time = now
        val endTime = calendar.timeInMillis
        calendar.add(Calendar.HOUR_OF_DAY, -1)
        val startTime = calendar.timeInMillis

        // Create a data source
        val dataSource = DataSource.Builder()
            .setAppPackageName(api.activity)
            .setDataType(DataType.TYPE_STEP_COUNT_DELTA)
            .setStreamName("$TAG - step count")
            .setType(DataSource.TYPE_RAW)
            .build()

        // Create a data set
        val stepCountDelta = 950
        return DataSet.builder(dataSource)
            .add(
                DataPoint.builder(dataSource)
                .setField(Field.FIELD_STEPS, stepCountDelta)
                .setTimeInterval(startTime, endTime, TimeUnit.MILLISECONDS)
                .build()
            ).build()
        // [END build_insert_data_request]
    }

    /** Returns a [DataReadRequest] for all step count changes in the past week.  */
    private fun queryFitnessData(): DataReadRequest {
        // [START build_read_data_request]
        // Setting a start and end date using a range of 1 week before this moment.
        val calendar = Calendar.getInstance(TimeZone.getTimeZone("UTC"))
        val now = Date()
        calendar.time = now
        val endTime = calendar.timeInMillis
        calendar.add(Calendar.WEEK_OF_YEAR, -1)
        val startTime = calendar.timeInMillis

        Log.i(TAG, "Range Start: ${DateFormat.getDateInstance().format(startTime)}")
        Log.i(TAG, "Range End: ${DateFormat.getDateInstance().format(endTime)}")
        Toast.makeText(api.activity, "Range Start: ${DateFormat.getDateInstance().format(startTime)}", Toast.LENGTH_LONG).show()
        Toast.makeText(api.activity, "Range End: ${DateFormat.getDateInstance().format(endTime)}", Toast.LENGTH_LONG).show()

        return DataReadRequest.Builder()
            // The data request can specify multiple data types to return, effectively
            // combining multiple data queries into one call.
            // In this example, it's very unlikely that the request is for several hundred
            // datapoints each consisting of a few steps and a timestamp.  The more likely
            // scenario is wanting to see how many steps were walked per day, for 7 days.
            .aggregate(DataType.TYPE_STEP_COUNT_DELTA, DataType.AGGREGATE_STEP_COUNT_DELTA)
            // Analogous to a "Group By" in SQL, defines how data should be aggregated.
            // bucketByTime allows for a time span, whereas bucketBySession would allow
            // bucketing by "sessions", which would need to be defined in code.
            .bucketByTime(1, TimeUnit.DAYS)
            .setTimeRange(startTime, endTime, TimeUnit.MILLISECONDS)
            .build()
    }

    private fun printData(dataReadResult: DataReadResponse) {
        // [START parse_read_data_result]
        // If the DataReadRequest object specified aggregated data, dataReadResult will be returned
        // as buckets containing DataSets, instead of just DataSets.
        if (dataReadResult.buckets.isNotEmpty()) {
            Log.i(TAG, "Number of returned buckets of DataSets is: " + dataReadResult.buckets.size)
            Toast.makeText(api.activity, "Number of returned buckets of DataSets is: " + dataReadResult.buckets.size, Toast.LENGTH_LONG).show()
            for (bucket in dataReadResult.buckets) {
                bucket.dataSets.forEach { dumpDataSet(it) }
            }
        } else if (dataReadResult.dataSets.isNotEmpty()) {
            Log.i(TAG, "Number of returned DataSets is: " + dataReadResult.dataSets.size)
            Toast.makeText(api.activity, "Number of returned DataSets is: " + dataReadResult.dataSets.size, Toast.LENGTH_LONG).show()
            dataReadResult.dataSets.forEach { dumpDataSet(it) }
        }
        // [END parse_read_data_result]
    }

    // [START parse_dataset]
    private fun dumpDataSet(dataSet: DataSet) {
        Log.i(TAG, "Data returned for Data type: ${dataSet.dataType.name}")
        Toast.makeText(api.activity, "Data returned for Data type: ${dataSet.dataType.name}", Toast.LENGTH_LONG).show()

        for (dp in dataSet.dataPoints) {
            Log.i(TAG, "Data point:")
            Log.i(TAG, "\tType: ${dp.dataType.name}")
            Log.i(TAG, "\tStart: ${dp.getStartTimeString()}")
            Log.i(TAG, "\tEnd: ${dp.getEndTimeString()}")
            dp.dataType.fields.forEach {
                Log.i(TAG, "\tField: ${it.name} Value: ${dp.getValue(it)}")
            }
        }
    }

    fun DataPoint.getStartTimeString(): String = DateFormat.getTimeInstance()
        .format(this.getStartTime(TimeUnit.MILLISECONDS))

    fun DataPoint.getEndTimeString(): String = DateFormat.getTimeInstance()
        .format(this.getEndTime(TimeUnit.MILLISECONDS))

    /**
     * Deletes a [DataSet] from the History API. In this example, we delete all step count data
     * for the past 24 hours.
     */
    private fun deleteData() {
        Log.i(TAG, "Deleting today's step count data.")
        Toast.makeText(api.activity, "Deleting today's step count data.", Toast.LENGTH_LONG).show()

        // [START delete_dataset]
        // Set a start and end time for our data, using a start time of 1 day before this moment.
        val calendar = Calendar.getInstance(TimeZone.getTimeZone("UTC"))
        val now = Date()
        calendar.time = now
        val endTime = calendar.timeInMillis
        calendar.add(Calendar.DAY_OF_YEAR, -1)
        val startTime = calendar.timeInMillis

        //  Create a delete request object, providing a data type and a time interval
        val request = DataDeleteRequest.Builder()
            .setTimeInterval(startTime, endTime, TimeUnit.MILLISECONDS)
            .addDataType(DataType.TYPE_STEP_COUNT_DELTA)
            .build()

        // Invoke the History API with the HistoryClient object and delete request, and then
        // specify a callback that will check the result.
        Fitness.getHistoryClient(api.activity, api.getGoogleAccount())
            .deleteData(request)
            .addOnSuccessListener {
                Log.i(TAG, "Successfully deleted today's step count data.")
                Toast.makeText(api.activity, "Successfully deleted today's step count data.", Toast.LENGTH_LONG).show()
            }
            .addOnFailureListener { e ->
                Log.e(TAG, "Failed to delete today's step count data.", e)
                Toast.makeText(api.activity, "Failed to delete today's step count data.", Toast.LENGTH_LONG).show()
            }
    }

    /**
     * Updates and reads data by chaining [Task] from [.updateData] and [ ][.readHistoryData].
     */
    private fun updateAndReadData() = updateData().continueWithTask { readHistoryData() }

    private fun updateData(): Task<Void> {
        // Create a new dataset and update request.
        val dataSet = updateFitnessData()
        val startTime = dataSet.dataPoints[0].getStartTime(TimeUnit.MILLISECONDS)
        val endTime = dataSet.dataPoints[0].getEndTime(TimeUnit.MILLISECONDS)
        // [START update_data_request]
        Log.i(TAG, "Updating the dataset in the History API.")
        Toast.makeText(api.activity, "Updating the dataset in the History API.", Toast.LENGTH_LONG).show()

        val request = DataUpdateRequest.Builder()
            .setDataSet(dataSet)
            .setTimeInterval(startTime, endTime, TimeUnit.MILLISECONDS)
            .build()

        // Invoke the History API to update data.
        return Fitness.getHistoryClient(api.activity, api.getGoogleAccount())
            .updateData(request)
            .addOnSuccessListener { Log.i(TAG, "Data update was successful.") }
            .addOnFailureListener { e ->
                Log.e(TAG, "There was a problem updating the dataset.", e)
                Toast.makeText(api.activity, "There was a problem updating the dataset.", Toast.LENGTH_LONG).show()
            }
    }

    /** Creates and returns a {@link DataSet} of step count data to update. */
    private fun updateFitnessData(): DataSet {
        Log.i(TAG, "Creating a new data update request.")
        Toast.makeText(api.activity, "Creating a new data update request.", Toast.LENGTH_LONG).show()

        // [START build_update_data_request]
        // Set a start and end time for the data that fits within the time range
        // of the original insertion.
        val calendar = Calendar.getInstance(TimeZone.getTimeZone("UTC"))
        val now = Date()
        calendar.time = now
        val endTime = calendar.timeInMillis
        calendar.add(Calendar.MINUTE, -50)
        val startTime = calendar.timeInMillis

        // Create a data source
        val dataSource = DataSource.Builder()
            .setAppPackageName(api.activity)
            .setDataType(DataType.TYPE_STEP_COUNT_DELTA)
            .setStreamName("$TAG - step count")
            .setType(DataSource.TYPE_RAW)
            .build()

        // Create a data set
        val stepCountDelta = 1000
        // For each data point, specify a start time, end time, and the data value -- in this case,
        // the number of new steps.
        return DataSet.builder(dataSource)
            .add(
                DataPoint.builder(dataSource)
                .setField(Field.FIELD_STEPS, stepCountDelta)
                .setTimeInterval(startTime, endTime, TimeUnit.MILLISECONDS)
                .build()
            ).build()
        // [END build_update_data_request]
    }
}