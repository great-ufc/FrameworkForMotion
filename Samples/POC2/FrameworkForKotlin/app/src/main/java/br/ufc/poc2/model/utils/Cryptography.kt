//------Generated by the Framework and can be changed-----//
//------Cryptograph Functions-----//

package br.ufc.great.qolmonitor.util

import android.content.Context
import android.os.Build
import androidx.annotation.RequiresApi
import java.nio.charset.StandardCharsets
import java.security.*
import java.security.spec.EncodedKeySpec
import java.security.spec.X509EncodedKeySpec
import java.util.*
import java.util.Base64.getEncoder
import javax.crypto.*
import javax.crypto.spec.IvParameterSpec


object Cryptography {

    private val TAG = Cryptography::class.java.simpleName
    private const val AES_KEY_SIZE = 256
    private const val RSA_CIPHER_ALG = "RSA/ECB/PKCS1Padding"
    private const val AES_CIPHER_ALG = "AES/CBC/PKCS5Padding"

    @RequiresApi(Build.VERSION_CODES.O)
    fun encryptWithRSA(context: Context, input: String): String{
        val encryptCipher = Cipher.getInstance(RSA_CIPHER_ALG)
        encryptCipher.init(Cipher.ENCRYPT_MODE, getRSAPublicKey(context))
        val secretMessageBytes: ByteArray = input.toByteArray(StandardCharsets.UTF_8)
        val encryptedMessageBytes = encryptCipher.doFinal(secretMessageBytes)
        return getEncoder().encodeToString(encryptedMessageBytes)
    }

    @RequiresApi(Build.VERSION_CODES.O)
    private fun getRSAPublicKey(context: Context): PublicKey {
        val publicKeyB64 = ""//context.getString(R.string.public_64b)
        val keyFactory: KeyFactory = KeyFactory.getInstance("RSA")
        val publicKeySpec: EncodedKeySpec = X509EncodedKeySpec(Base64.getDecoder().decode(publicKeyB64))
        return keyFactory.generatePublic(publicKeySpec)
    }

    @RequiresApi(Build.VERSION_CODES.O)
    fun getKeyAsBase64(key: SecretKey): String{
        return getEncoder().encodeToString(key.encoded)
    }

    fun generateRandomAESKey(): SecretKey {
        val keyGenerator = KeyGenerator.getInstance("AES")
        keyGenerator.init(AES_KEY_SIZE)
        return keyGenerator.generateKey()
    }

    fun generateIv(): IvParameterSpec {
        val iv = ByteArray(16)
        SecureRandom().nextBytes(iv)
        return IvParameterSpec(iv)
    }

    @RequiresApi(Build.VERSION_CODES.O)
    fun encryptWithAES(key: SecretKey, iv: IvParameterSpec, input: String): String{
        val cipher = Cipher.getInstance(AES_CIPHER_ALG)
        cipher.init(Cipher.ENCRYPT_MODE, key, iv)
        val cipherText = cipher.doFinal(input.toByteArray())
        return getEncoder().encodeToString(cipherText)
    }
}