//------Generated by the Framework and can be changed-----//
//------Feature Extraction Class-----//

package br.ufc.frameworkkotlin.model.mapek.analysis

import br.ufc.frameworkkotlin.model.entities.ValuesFeatures
import br.ufc.frameworkkotlin.model.entities.sensors.ValuesACC
import br.ufc.frameworkkotlin.model.entities.VerticeFeature
import br.ufc.frameworkkotlin.model.entities.sensors.typeSensor
import br.ufc.frameworkkotlin.ui.CommonActivities.BaseActivity
import kotlin.math.pow
import kotlin.math.sqrt

class FeatureExtraction(val context: BaseActivity)  {

    fun featureDataExtraction():MutableList<VerticeFeature> {

        //<Aqui são adicionadas as features para cada sensor>//

        val values = mutableListOf<Any>();

        for (data in context.datas) {
            if(data.idSensor == "ACC") {
                val value = data.value as ValuesACC
                values += SMV(value.eixoX, value.eixoY, value.eixoZ);
            }
        }

        //<FIM da adição as features para cada sensor>//
        return getFeatures(values);

    }

    ///////////////<CALCULO DE SMV PARA SENSORES TRIAXIAIS>/////////////////////
    fun SMV(axisX:Double, axisY:Double, axisZ:Double):Double{
            return sqrt(axisX.pow(2) + axisY.pow(2) + axisZ.pow(2));
    }
    ///////////////<FIM CALCULO DE SMV PARA SENSORES TRIAXIAIS>/////////////////////

    fun getFeatures(values:MutableList<Any>?): MutableList<VerticeFeature>{
         var features = mutableListOf<VerticeFeature>();

        ///////////////VALORES FEATURES/////////////////////

        //----Valores Accelerometer-----//
        features+= VerticeFeature(FeatureFunctions.Mean(values as MutableList<Double>), ValuesFeatures(typeSensor.ACC.name,"mean"));//média
        features+= VerticeFeature(FeatureFunctions.Max(values as MutableList<Double>), ValuesFeatures(typeSensor.ACC.name,"max"));//Valor Máximo
        features+= VerticeFeature(FeatureFunctions.Min(values as MutableList<Double>), ValuesFeatures(typeSensor.ACC.name,"min"));//Valor Mínimo
        features+= VerticeFeature(FeatureFunctions.STD(values as MutableList<Double>), ValuesFeatures(typeSensor.ACC.name,"std"));//Desvio Padrão
        features+= VerticeFeature(FeatureFunctions.Kurtosis(values as MutableList<Double>), ValuesFeatures(typeSensor.ACC.name,"kurrtosis"));//Kurtosis
        features+= VerticeFeature(FeatureFunctions.Skewness(values as MutableList<Double>), ValuesFeatures(typeSensor.ACC.name,"skewness"));//Skewness
        features+= VerticeFeature(FeatureFunctions.Entropy(values as MutableList<Double>), ValuesFeatures(typeSensor.ACC.name,"entropy"));//Entropy
        features+= VerticeFeature(FeatureFunctions.MAD(values as MutableList<Double>), ValuesFeatures(typeSensor.ACC.name,"MAD"));//Mean Absolute Devination
        features+= VerticeFeature(FeatureFunctions.IQR(values as MutableList<Double>), ValuesFeatures(typeSensor.ACC.name,"IQR"));//IQR
        /*
        features.add(new VerticeFeature((float)IQR(smvValues), "accIQR"));//  iqr
        */
        //features.add(RMS(smvValues));//Valor de RMS -- não é usado
        //----Valores Gyroscope-----//
        /*
        features.add(new VerticeFeature(0, "gyrMean"));//média
        features.add(new VerticeFeature(0, "gyrMax"));//Valor Máximo
        features.add(new VerticeFeature(0, "gyrMin"));//valor mínimo
        features.add(new VerticeFeature(0, "gyrSTD"));//Desvio padrão
        features.add(new VerticeFeature(0, "gyrKur"));//Kutosis
        features.add(new VerticeFeature(0, "gyrSkew"));//Skewness
        features.add(new VerticeFeature(0, "gyrEntr"));//Entropy
        features.add(new VerticeFeature(0, "gyrMAD"));//Median_absolute_deviation
        features.add(new VerticeFeature(0, "gyrIQR"));//iqr
        */


        ///////////////FINAL VALORES FEATURES/////////////////////

        return features;
    }

}