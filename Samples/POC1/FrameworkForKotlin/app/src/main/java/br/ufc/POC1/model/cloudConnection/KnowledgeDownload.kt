//------Generated by the Framework and can be changed-----//
//------Methods for download Classification Graph-----//

package br.ufc.POC1.model.cloudConnection

import android.content.res.AssetManager
import android.os.StrictMode
import android.util.Log
import br.ufc.POC1.ui.MainActivity
import br.ufc.POC1.model.entities.*
import br.ufc.POC1.model.utils.Constants
import br.ufc.POC1.ui.CommonActivities.BaseActivity
import okhttp3.OkHttpClient
import okhttp3.Request
import org.tensorflow.lite.Interpreter
import java.io.*
import java.lang.Exception
import java.net.URL
import java.nio.MappedByteBuffer
import java.nio.channels.Channels
import java.nio.channels.FileChannel


class KnowledgeDownload {
    companion object{
        //Atualiza base de conhecimento
        fun update(mutableList: MutableList<VerticeFeature>, context: BaseActivity): KnowledgeRepresentation{
            //faz a solicitação informando os sensores e possíveis fetures
            // /OptimizeGraphRequest/acc/<threshold value>
            // /OptimizeGraphRequest/download.xml
            var knowledgeGraph:String? = null
            try {
                knowledgeGraph =
                    downloadXML(Constants.LAST_OPTIMIZE_GRAPH_ADDRESS, context);
                Log.i("Result", "Download do Grafo executado")
            }catch (e:Exception){
                e.printStackTrace()
                Log.i("Download Error","Não foi possível baixar o Grafo")
            }

            //Se não conseguir baixar tentausar o último grafo baixado
            if(knowledgeGraph == null){
                try {
                    knowledgeGraph = BufferedReader(FileReader(File(context.baseDirectory+"/KnowledgeGraph.xml"))).readText()
                }catch (e:Exception){
                    e.printStackTrace()
                }
            }

            //baixa o grafo e preenche base de conhecimento
            var knowledgeRepresentation = readXMLGraph(knowledgeGraph!!, mutableList)

            //baixa modelos treinados e atualiza base de conhecimento

            downloadModels(knowledgeRepresentation, context)

            //adiciona os modelos treinados a base de conhecimento
            knowledgeRepresentation = updateKnowledgeRepresentationTfLite(knowledgeRepresentation, context)
            knowledgeRepresentation = updateKnowledgeRepresentationOnnx(knowledgeRepresentation)

            return knowledgeRepresentation

        }

        //Intancia modelos Onnx
        fun updateKnowledgeRepresentationOnnx(knowledgeRepresentation: KnowledgeRepresentation):KnowledgeRepresentation{
            //Not Implemented
            return knowledgeRepresentation
        }

        //Intancia modelos tflite
        fun updateKnowledgeRepresentationTfLite(knowledgeRepresentation: KnowledgeRepresentation, context: BaseActivity):KnowledgeRepresentation{
            try {
                for (models in knowledgeRepresentation.edgeModelsFinalStatus) {
                    if(models.vModel.modelName.split(".")[1].contains("tflite")){
                        val base = context.baseDirectory
                        val outFile = base+"/saved_model/"+ models.vModel.modelName
                        var interpreter = Interpreter(loadModelFile(outFile,context.assetManager!!)!!, null)
                        models.vModel.setSmartModel(interpreter)
                    }
                }
            } catch (e: IOException) {
                e.printStackTrace();
            }
            return knowledgeRepresentation
        }

        //Intancia um modelo tersorflow lite
        fun loadModelFile(model:String,manager: AssetManager): MappedByteBuffer? {
            val inputStream: FileInputStream = FileInputStream(model)
            val declaredLength: Long = File(model).length()
            val fileChannel = inputStream.channel
            return fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, declaredLength)
        }

        //Executa Download do grafo de classificação
        fun downloadXML(url:String, context: BaseActivity):String {
            val client = OkHttpClient()
            val policy = StrictMode.ThreadPolicy.Builder().permitAll().build()
            StrictMode.setThreadPolicy(policy)
            val request = Request.Builder()
                .url(url)
                .build()

            client.newCall(request).execute().use { response ->
                if (!response.isSuccessful) throw IOException("Unexpected code $response")

                for ((name, value) in response.headers) {
                    println("$name: $value")
                }
                val xml = response.body!!.string()
                val fileW = BufferedWriter(FileWriter(File(context.baseDirectory+"/KnowledgeGraph.xml")))
                fileW.write(xml)
                fileW.close()
                return xml
            }
            return ""
        }

        //Executa download dos modelos treinados
        fun downloadModels(knowledgeRepresentation: KnowledgeRepresentation, context: BaseActivity){

            var models = mutableListOf<String>()
            for(emodels in knowledgeRepresentation.edgeModelsFinalStatus){
                if(!models.contains(emodels.vModel.modelName))
                    models.add(emodels.vModel.modelName)
            }

            for(model in models){
                val urlBase = Constants.SAVED_MODELS_ADDRESS
                val url = URL(urlBase+model)
                try{
                    downloadModel(url,model, context)
                    //download2(urlBase+model,"/saved_model/"+model)
                }catch (e:Exception){
                    e.printStackTrace()
                    Log.i("Download Error","Não foi possível baixar os modelos")
                    MainActivity.texto =  "Não foi possível baixar o modelo "+model+". Usando Modelos Locais"
                }
            }
        }

        //Executa um download
        fun downloadModel(url: URL, outputFileName: String, context: BaseActivity) {
            val base = context.baseDirectory
            if(!File(base+"/saved_model/").exists())
                File(base+"/saved_model/").mkdirs();
            val outFile = base+"/saved_model/"+"$outputFileName"
            url.openStream().use {
                Channels.newChannel(it).use { rbc ->
                    FileOutputStream(outFile).use { fos ->
                        fos.channel.transferFrom(rbc, 0, Long.MAX_VALUE)
                    }
                }
            }
        }

        //Monta Base de conhecimento com base no grafo de classificação que foi baixado
        fun readXMLGraph(xml: String, featuresList: MutableList<VerticeFeature>? = null): KnowledgeRepresentation {
            var knowledgeRepresentation: KnowledgeRepresentation
            val xmlLines = xml.replace("\r", "").split("\n")

            //flag to identify edges
            var esfflag = false
            var efmflag = false
            var emfsflag = false

            //flag to identify vertices
            var vfflag = false
            var vmflag = false

            //KnowledgeRepresentation Content
            var edgeSensorFeature = mutableListOf<EdgeSensorFeature>()
            var edgeFeatureModel = mutableListOf<EdgeFeatureModel>()
            var edgeModelFinalStatus = mutableListOf<EdgeModelsFinalStatus>()

            //List of Entities
            var vSensor: VerticeSensor? = null
            var vFeature:VerticeFeature? = null
            var vModel: VerticeModel? = null
            var vFinalStatus: VerticeFinalStatus?=null

            //List of aux values for feature
            var idSensor = ""
            var nameFeature = ""

            //List of aux values for Model
            var inFeature = 0
            var modelName = ""
            var outFeature = 0

            //ModelFinalStatus probability aux
            var probability = 0.0

            for (line in xmlLines){

                /****edgeSensorFeature***/

                //verify edgeSensorFeature start
                if (line.contains("EdgeSensorFeature"))
                    esfflag = true

                //add Sensor for SensorFeature edges
                if (line.contains("typeSensor") and esfflag)
                    vSensor = VerticeSensor(line.replace("<typeSensor>", "").replace("</typeSensor>", ""))

                //add Feature for SensorFeature edges start
                if (line.contains("featureName") and esfflag)
                    vfflag = true

                if (line.contains("idSensor") and esfflag and vfflag)
                    idSensor = line.replace("<idSensor>", "").replace("</idSensor>", "")

                if (line.contains("name") and esfflag and vfflag)
                    nameFeature = line.replace("<name>", "").replace("</name>", "")

                //add Feature for SensorFeature edges ends
                if (line.contains("/featureName") and esfflag and vfflag){
                    var value:Double? = null
                    for(f in featuresList!!){
                        if((f.featureName.idSensor == idSensor) and (f.featureName.name == nameFeature)){
                            value = f.feature
                            break
                        }
                    }
                    if (value != null)
                        vFeature = VerticeFeature(value!!, ValuesFeatures(idSensor,nameFeature))
                    else
                        vFeature = VerticeFeature(0.0, ValuesFeatures(idSensor,nameFeature))
                    idSensor = ""
                    nameFeature = ""
                    vfflag = false
                }


                //verify edgeSensorFeature ends
                if (line.contains("/EdgeSensorFeature") and esfflag){
                    edgeSensorFeature.add(EdgeSensorFeature(vSensor!!,vFeature!!))
                    vFeature = null
                    vSensor = null
                    esfflag = false
                }

                /****edgeFeatureModel***/

                //verify an edgeModelFeature starts
                if (line.contains("EdgeFeatureModel"))
                    efmflag = true

                //add Feature for FeatureModel start
                if (line.contains("featureName") and efmflag)
                    vfflag = true

                if (line.contains("idSensor") and efmflag and vfflag)
                    idSensor = line.replace("<idSensor>", "").replace("</idSensor>", "")

                if (line.contains("name") and efmflag and vfflag)
                    nameFeature = line.replace("<name>", "").replace("</name>", "")

                //add Feature for FeatureModel ends
                if (line.contains("/featureName") and efmflag and vfflag){
                    var value:Double? = null
                    for(f in featuresList!!){
                        if((f.featureName.idSensor == idSensor) and (f.featureName.name == nameFeature)){
                            value = f.feature
                            break
                        }
                    }
                    if (value != null)
                        vFeature = VerticeFeature(value!!, ValuesFeatures(idSensor,nameFeature))
                    else
                        vFeature = VerticeFeature(0.0, ValuesFeatures(idSensor,nameFeature))
                    idSensor = ""
                    nameFeature = ""
                    vfflag = false
                }

                //add Model for FeatureModel starts
                if(line.contains("vModel") and efmflag)
                    vmflag = true

                ///inFeature
                if(line.contains("inFeature") and efmflag and vmflag)
                    inFeature = (line.replace("<inFeature>", "").replace("</inFeature>", "")).replace(" ","").toInt()

                //modelName
                if(line.contains("modelName") and efmflag and vmflag)
                    modelName = line.replace("<modelName>", "").replace("</modelName>", "")

                //outFeature
                if(line.contains("outFeature") and efmflag and vmflag)
                    inFeature = (line.replace("<outFeature>", "").replace("</outFeature>", "")).replace(" ","").toInt()

                //add Model for FeatureModel ends
                if (line.contains("/vModel") and efmflag and vmflag){
                    vModel = VerticeModel(modelName,inFeature,outFeature)
                    inFeature = 0
                    modelName = ""
                    inFeature = 0
                    vmflag = false
                }

                //verify an edgeFeatureModel ends
                if (line.contains("/EdgeFeatureModel") and efmflag){
                    edgeFeatureModel.add(EdgeFeatureModel(vFeature!!,vModel!!))
                    vFeature = null
                    vModel = null
                    efmflag = false
                }

                /****edgeModelFinalStatus***/

                //verify an edgeModelFeature starts
                if (line.contains("EdgeModelsFinalStatus"))
                    emfsflag = true

                //add Model for FeatureModel starts
                if(line.contains("vModel") and emfsflag)
                    vmflag = true

                ///inFeature
                if(line.contains("inFeature") and emfsflag and vmflag)
                    inFeature = (line.replace("<inFeature>", "").replace("</inFeature>", "")).toInt()

                //modelName
                if(line.contains("modelName") and emfsflag and vmflag)
                    modelName = line.replace("<modelName>", "").replace("</modelName>", "")

                //outFeature
                if(line.contains("outFeature") and emfsflag and vmflag)
                    outFeature = (line.replace("<outFeature>", "").replace("</outFeature>", "")).toInt()

                //add Model for ModelFinalStatus ends
                if (line.contains("/vModel") and emfsflag and vmflag){
                    vModel = VerticeModel(modelName,inFeature,outFeature)
                    inFeature = 0
                    modelName = ""
                    inFeature = 0
                    vmflag = false
                }

                //add final status for ModelFinalStatus
                if(line.contains("finalStatus") and emfsflag)
                    vFinalStatus = VerticeFinalStatus(line.replace("<finalStatus>", "").replace("</finalStatus>", ""))

                //add probability for ModelFinalStatus
                if(line.contains("probability") and emfsflag)
                    probability = (line.replace("<probability>", "").replace("</probability>", "")).toDouble()


                //verify an edgeModelFinalStatus ends
                if (line.contains("/EdgeModelsFinalStatus") and emfsflag){
                    edgeModelFinalStatus.add(EdgeModelsFinalStatus(vModel!!,vFinalStatus!!, probability))
                    vModel = null
                    vFinalStatus = null
                    emfsflag = false
                }

            }
            knowledgeRepresentation = KnowledgeRepresentation(edgeSensorFeature,edgeFeatureModel,edgeModelFinalStatus)

            return knowledgeRepresentation
        }
    }
}